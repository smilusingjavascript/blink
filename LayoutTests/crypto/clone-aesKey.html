<!DOCTYPE html>
<html>
<head>
<script src="../resources/js-test.js"></script>
<script src="resources/common.js"></script>
</head>
<body>
<p id="description"></p>
<div id="console"></div>

<script>
description("Tests structured cloning of AES keys");

jsTestIsAsync = true;

// Tests the 32 permutations of keys generated by:
//   kPossibleAlgorithms x kPossibleExtractable x kPossibleKeyUsages x kPossibleKeyData
//
// For practical reasons these tests are not exhaustive.

var k128BitData = "30112233445566778899aabbccddeeff"
var k256BitData = "00112233445546778899aabbccddeeff000102030405060708090a0b0c0d0e0f";

var kPossibleAlgorithms = ['AES-CBC', 'AES-GCM'];
var kPossibleExtractable = [true, false];
var kPossibleKeyUsages = [[], ['encrypt'], ['decrypt', 'wrapKey'], ['encrypt', 'wrapKey', 'unwrapKey']];
var kPossibleKeyData = [k128BitData, k256BitData];

function runTest(algorithmName, extractable, keyUsages, keyData)
{
    var importData = hexStringToUint8Array(keyData);
    var importAlgorithm = { name: algorithmName };

    var results = {};

    return crypto.subtle.importKey('raw', importData, importAlgorithm, extractable, keyUsages).then(function(importedKey) {
        results.importedKey = importedKey;
        importedKey.extraProperty = 'hi';
        return cloneKey(importedKey);
    }).then(function(clonedKey) {
        results.clonedKey = clonedKey;
        if (extractable)
            return crypto.subtle.exportKey('raw', clonedKey);
        return null;
    }).then(function(clonedKeyData) {
        importedKey = results.importedKey;
        clonedKey = results.clonedKey;

        shouldEvaluateAs("importedKey.extraProperty", "hi");
        shouldEvaluateAs("importedKey.type", "secret");
        shouldEvaluateAs("importedKey.extractable", extractable);
        shouldEvaluateAs("importedKey.algorithm.name", algorithmName);
        shouldEvaluateAs("importedKey.algorithm.length", importData.length * 8);
        shouldEvaluateAs("importedKey.usages.join(',')", keyUsages.join(","));

        shouldNotBe("importedKey", "clonedKey");

        shouldBeUndefined("clonedKey.extraProperty");
        shouldEvaluateAs("clonedKey.type", "secret");
        shouldEvaluateAs("clonedKey.extractable", extractable);
        shouldEvaluateAs("clonedKey.algorithm.name", algorithmName);
        shouldEvaluateAs("clonedKey.algorithm.length", importData.length * 8);
        shouldEvaluateAs("clonedKey.usages.join(',')", keyUsages.join(","));

        logSerializedKey(importedKey);

        if (extractable)
            bytesShouldMatchHexString("Cloned key exported data", keyData, clonedKeyData);

        debug("");
    });
}

var lastPromise = Promise.resolve(null);

kPossibleAlgorithms.forEach(function(algorithmName) {
    kPossibleExtractable.forEach(function(extractable) {
        kPossibleKeyUsages.forEach(function(keyUsages) {
            kPossibleKeyData.forEach(function(keyData) {
                lastPromise = lastPromise.then(runTest.bind(null, algorithmName, extractable, keyUsages, keyData));
            });
        });
    });
});

lastPromise.then(finishJSTest, failAndFinishJSTest);

</script>

</body>
</html>
