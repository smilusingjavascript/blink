<!DOCTYPE html>
<html>
<head>
<script src="../resources/js-test.js"></script>
<script src="resources/common.js"></script>
<script src="resources/keys.js"></script>
</head>
<body>
<p id="description"></p>
<div id="console"></div>

<script>
description("Tests structured cloning of RSA private keys (with a hash)");

jsTestIsAsync = true;

// Tests the 12 permutations of keys generated by:
//   kPossibleAlgorithms x kPossibleExtractable x kPossibleKeyUsages x kPossibleKeyData x kPossibleHashAlgorithms
//
// For practical reasons these tests are not exhaustive.

var kPossibleAlgorithms = ['RSASSA-PKCS1-v1_5'];
var kPossibleExtractable = [true, false];
var kPossibleKeyUsages = [[], ['sign']];
var kPossibleHashAlgorithms = ['SHA-1', 'SHA-256', 'SHA-512'];

var kPossibleKeyData = [
    kKeyData.rsa1,
    kKeyData.rsa4
];

function runTest(algorithmName, hashName, extractable, keyUsages, keyData)
{
    var importData = hexStringToUint8Array(keyData.pkcs8);
    var importAlgorithm = { name: algorithmName, hash: {name: hashName} };

    var results = {};

    return crypto.subtle.importKey('pkcs8', importData, importAlgorithm, extractable, keyUsages).then(function(importedKey) {
        results.importedKey = importedKey;
        importedKey.extraProperty = 'hi';
        return cloneKey(importedKey);
    }).then(function(clonedKey) {
        results.clonedKey = clonedKey;
        if (extractable)
            return crypto.subtle.exportKey('pkcs8', clonedKey);
        return null;
    }).then(function(clonedKeyData) {
        importedKey = results.importedKey;
        clonedKey = results.clonedKey;

        shouldEvaluateAs("importedKey.extraProperty", "hi");
        shouldEvaluateAs("importedKey.type", "private");
        shouldEvaluateAs("importedKey.extractable", extractable);
        shouldEvaluateAs("importedKey.algorithm.name", algorithmName);
        shouldEvaluateAs("importedKey.algorithm.modulusLength", keyData.modulusLengthBits);
        bytesShouldMatchHexString("importedKey.algorithm.publicExponent", keyData.publicExponent, importedKey.algorithm.publicExponent);
        shouldEvaluateAs("importedKey.algorithm.hash.name", hashName);
        shouldEvaluateAs("importedKey.usages.join(',')", keyUsages.join(","));

        shouldNotBe("importedKey", "clonedKey");

        shouldBeUndefined("clonedKey.extraProperty");
        shouldEvaluateAs("clonedKey.type", "private");
        shouldEvaluateAs("clonedKey.extractable", extractable);
        shouldEvaluateAs("clonedKey.algorithm.name", algorithmName);
        shouldEvaluateAs("clonedKey.algorithm.modulusLength", keyData.modulusLengthBits);
        bytesShouldMatchHexString("clonedKey.algorithm.publicExponent", keyData.publicExponent, clonedKey.algorithm.publicExponent);
        shouldEvaluateAs("clonedKey.algorithm.hash.name", hashName);
        shouldEvaluateAs("clonedKey.usages.join(',')", keyUsages.join(","));

        logSerializedKey(importedKey);

        if (extractable)
            bytesShouldMatchHexString("Cloned key exported data", keyData.pkcs8, clonedKeyData);

        debug("");
    });
}

var lastPromise = Promise.resolve(null);

kPossibleAlgorithms.forEach(function(algorithmName) {
    kPossibleExtractable.forEach(function(extractable) {
        kPossibleKeyUsages.forEach(function(keyUsages) {
            kPossibleKeyData.forEach(function(keyData) {
                kPossibleHashAlgorithms.forEach(function(hashName) {
                    lastPromise = lastPromise.then(runTest.bind(null, algorithmName, hashName, extractable, keyUsages, keyData));
                });
            });
        });
    });
});

lastPromise.then(finishJSTest, failAndFinishJSTest);

</script>

</body>
</html>
